/*
 * API Reference
 *
 * Sentry Public API
 *
 * The version of the OpenAPI document: v0
 * Contact: partners@sentry.io
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`create_a_new_deploy_for_an_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateANewDeployForAnOrganizationError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_a_new_release_for_an_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateANewReleaseForAnOrganizationError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_a_project_release_quote_s_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAProjectReleaseQuoteSFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_an_organization_quote_s_release`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAnOrganizationQuoteSReleaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_an_organization_release_quote_s_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAnOrganizationReleaseQuoteSFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_a_project_quote_s_release_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAProjectQuoteSReleaseFilesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_a_project_release_quote_s_commits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAProjectReleaseQuoteSCommitsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_a_release_quote_s_deploys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAReleaseQuoteSDeploysError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_an_organization_quote_s_release_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAnOrganizationQuoteSReleaseFilesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_an_organization_quote_s_releases`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAnOrganizationQuoteSReleasesError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_an_organization_release_quote_s_commits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAnOrganizationReleaseQuoteSCommitsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_issues_to_be_resolved_in_a_particular_release`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIssuesToBeResolvedInAParticularReleaseError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_a_project_release_quote_s_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveAProjectReleaseQuoteSFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_an_organization_quote_s_releases`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveAnOrganizationQuoteSReleasesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_an_organization_release_quote_s_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveAnOrganizationReleaseQuoteSFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_files_changed_in_a_release_quote_s_commits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveFilesChangedInAReleaseQuoteSCommitsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_release_health_session_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveReleaseHealthSessionStatisticsError {
    Status400(crate::models::RetrieveReleaseHealthSessionStatistics400Response),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_a_project_release_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAProjectReleaseFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_an_organization_quote_s_release`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAnOrganizationQuoteSReleaseError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_an_organization_release_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAnOrganizationReleaseFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_a_new_organization_release_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadANewOrganizationReleaseFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_a_new_project_release_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadANewProjectReleaseFileError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Create a deploy.
pub async fn create_a_new_deploy_for_an_organization(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
    create_a_new_deploy_for_an_organization_request: Option<
        crate::models::CreateANewDeployForAnOrganizationRequest,
    >,
) -> Result<
    crate::models::RetrieveAnEventForAProject200ResponseReleaseOneOfLastDeployOneOf,
    Error<CreateANewDeployForAnOrganizationError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/deploys/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder =
        local_var_req_builder.json(&create_a_new_deploy_for_an_organization_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateANewDeployForAnOrganizationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new release for the given organization.  Releases are used by Sentry to improve its error reporting abilities by correlating first seen events with the release that might have introduced the problem. Releases are also necessary for source maps and other debug features that require manual upload for functioning well.
pub async fn create_a_new_release_for_an_organization(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    create_a_new_release_for_an_organization_request: Option<
        crate::models::CreateANewReleaseForAnOrganizationRequest,
    >,
) -> Result<
    crate::models::RetrieveAnEventForAProject200ResponseReleaseOneOf,
    Error<CreateANewReleaseForAnOrganizationError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder =
        local_var_req_builder.json(&create_a_new_release_for_an_organization_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateANewReleaseForAnOrganizationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a file for a given release.
pub async fn delete_a_project_release_quote_s_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project_slug: &str,
    version: &str,
    file_id: &str,
) -> Result<(), Error<DeleteAProjectReleaseQuoteSFileError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/files/{file_id}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        project_slug = crate::apis::urlencode(project_slug),
        version = crate::apis::urlencode(version),
        file_id = crate::apis::urlencode(file_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAProjectReleaseQuoteSFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a release for a given organization.
pub async fn delete_an_organization_quote_s_release(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
) -> Result<(), Error<DeleteAnOrganizationQuoteSReleaseError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAnOrganizationQuoteSReleaseError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a file for a given release.
pub async fn delete_an_organization_release_quote_s_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
    file_id: &str,
) -> Result<(), Error<DeleteAnOrganizationReleaseQuoteSFileError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/files/{file_id}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version),
        file_id = crate::apis::urlencode(file_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAnOrganizationReleaseQuoteSFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a list of files for a given release.
pub async fn list_a_project_quote_s_release_files(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project_slug: &str,
    version: &str,
) -> Result<
    Vec<crate::models::ListAnOrganizationSReleaseFiles200ResponseInner>,
    Error<ListAProjectQuoteSReleaseFilesError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/files/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        project_slug = crate::apis::urlencode(project_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListAProjectQuoteSReleaseFilesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List a project release's commits.
pub async fn list_a_project_release_quote_s_commits(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project_slug: &str,
    version: &str,
) -> Result<
    Vec<crate::models::ListARepositorySCommits200ResponseInner>,
    Error<ListAProjectReleaseQuoteSCommitsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/commits/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        project_slug = crate::apis::urlencode(project_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListAProjectReleaseQuoteSCommitsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a list of deploys for a given release.
pub async fn list_a_release_quote_s_deploys(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
) -> Result<
    Vec<crate::models::RetrieveAnEventForAProject200ResponseReleaseOneOfLastDeployOneOf>,
    Error<ListAReleaseQuoteSDeploysError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/deploys/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListAReleaseQuoteSDeploysError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a list of files for a given release.
pub async fn list_an_organization_quote_s_release_files(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
) -> Result<
    Vec<crate::models::ListAnOrganizationSReleaseFiles200ResponseInner>,
    Error<ListAnOrganizationQuoteSReleaseFilesError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/files/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListAnOrganizationQuoteSReleaseFilesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a list of releases for a given organization.
pub async fn list_an_organization_quote_s_releases(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    query: Option<&str>,
) -> Result<
    Vec<crate::models::RetrieveAnEventForAProject200ResponseReleaseOneOf>,
    Error<ListAnOrganizationQuoteSReleasesError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder =
            local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListAnOrganizationQuoteSReleasesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List an organization release's commits.
pub async fn list_an_organization_release_quote_s_commits(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
) -> Result<
    Vec<crate::models::ListARepositorySCommits200ResponseInner>,
    Error<ListAnOrganizationReleaseQuoteSCommitsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/commits/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListAnOrganizationReleaseQuoteSCommitsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List issues to be resolved in a particular release.
pub async fn list_issues_to_be_resolved_in_a_particular_release(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project_slug: &str,
    version: &str,
) -> Result<(), Error<ListIssuesToBeResolvedInAParticularReleaseError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/resolved/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        project_slug = crate::apis::urlencode(project_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ListIssuesToBeResolvedInAParticularReleaseError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a file for a given release.
pub async fn retrieve_a_project_release_quote_s_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project_slug: &str,
    version: &str,
    file_id: &str,
) -> Result<
    crate::models::ListAnOrganizationSReleaseFiles200ResponseInner,
    Error<RetrieveAProjectReleaseQuoteSFileError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/files/{file_id}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        project_slug = crate::apis::urlencode(project_slug),
        version = crate::apis::urlencode(version),
        file_id = crate::apis::urlencode(file_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RetrieveAProjectReleaseQuoteSFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a release for a given organization.
pub async fn retrieve_an_organization_quote_s_releases(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
) -> Result<
    crate::models::RetrieveAnEventForAProject200ResponseReleaseOneOf,
    Error<RetrieveAnOrganizationQuoteSReleasesError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RetrieveAnOrganizationQuoteSReleasesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a file for a given release.
pub async fn retrieve_an_organization_release_quote_s_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
    file_id: &str,
) -> Result<
    crate::models::ListAnOrganizationSReleaseFiles200ResponseInner,
    Error<RetrieveAnOrganizationReleaseQuoteSFileError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/files/{file_id}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version),
        file_id = crate::apis::urlencode(file_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RetrieveAnOrganizationReleaseQuoteSFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve files changed in a release's commits
pub async fn retrieve_files_changed_in_a_release_quote_s_commits(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
) -> Result<(), Error<RetrieveFilesChangedInAReleaseQuoteSCommitsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/commitfiles/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<RetrieveFilesChangedInAReleaseQuoteSCommitsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a time series of release health session statistics for projects bound to an organization.  The interval and date range are subject to certain restrictions and rounding rules.  The date range is rounded to align with the interval, and is rounded to at least one hour. The interval can at most be one day and at least one hour currently. It has to cleanly divide one day, for rounding reasons.  Apart from the query parameters listed below, this endpoint also supports the usual [pagination parameters](https://docs.sentry.io/api/pagination/).
pub async fn retrieve_release_health_session_statistics(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project: Vec<i32>,
    field: Vec<String>,
    environment: Option<Vec<String>>,
    group_by: Option<Vec<String>>,
    order_by: Option<&str>,
    query: Option<&str>,
    stats_period: Option<&str>,
    interval: Option<&str>,
    stats_period_start: Option<&str>,
    stats_period_end: Option<&str>,
    start: Option<String>,
    end: Option<String>,
) -> Result<
    crate::models::RetrieveReleaseHealthSessionStatistics200Response,
    Error<RetrieveReleaseHealthSessionStatisticsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/sessions/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(
            &project
                .into_iter()
                .map(|p| ("project".to_owned(), p.to_string()))
                .collect::<Vec<(std::string::String, std::string::String)>>(),
        ),
        _ => local_var_req_builder.query(&[(
            "project",
            &project
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]),
    };
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(
            &field
                .into_iter()
                .map(|p| ("field".to_owned(), p))
                .collect::<Vec<(std::string::String, std::string::String)>>(),
        ),
        _ => local_var_req_builder.query(&[(
            "field",
            &field
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]),
    };
    if let Some(ref local_var_str) = environment {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("environment".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "environment",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = group_by {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("groupBy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "groupBy",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = order_by {
        local_var_req_builder =
            local_var_req_builder.query(&[("orderBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder =
            local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stats_period {
        local_var_req_builder =
            local_var_req_builder.query(&[("statsPeriod", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = interval {
        local_var_req_builder =
            local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stats_period_start {
        local_var_req_builder =
            local_var_req_builder.query(&[("statsPeriodStart", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stats_period_end {
        local_var_req_builder =
            local_var_req_builder.query(&[("statsPeriodEnd", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end {
        local_var_req_builder = local_var_req_builder.query(&[("end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RetrieveReleaseHealthSessionStatisticsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a project release file.
pub async fn update_a_project_release_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project_slug: &str,
    version: &str,
    file_id: &str,
    update_an_organization_release_file_request: Option<
        crate::models::UpdateAnOrganizationReleaseFileRequest,
    >,
) -> Result<
    crate::models::ListAnOrganizationSReleaseFiles200ResponseInner,
    Error<UpdateAProjectReleaseFileError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/files/{file_id}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        project_slug = crate::apis::urlencode(project_slug),
        version = crate::apis::urlencode(version),
        file_id = crate::apis::urlencode(file_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder =
        local_var_req_builder.json(&update_an_organization_release_file_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateAProjectReleaseFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a release for a given organization.
pub async fn update_an_organization_quote_s_release(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
    update_an_organization_s_release_request: Option<
        crate::models::UpdateAnOrganizationSReleaseRequest,
    >,
) -> Result<
    crate::models::RetrieveAnEventForAProject200ResponseReleaseOneOf,
    Error<UpdateAnOrganizationQuoteSReleaseError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_an_organization_s_release_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateAnOrganizationQuoteSReleaseError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an organization release file.
pub async fn update_an_organization_release_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
    file_id: &str,
    update_an_organization_release_file_request: Option<
        crate::models::UpdateAnOrganizationReleaseFileRequest,
    >,
) -> Result<
    crate::models::ListAnOrganizationSReleaseFiles200ResponseInner,
    Error<UpdateAnOrganizationReleaseFileError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/files/{file_id}/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version),
        file_id = crate::apis::urlencode(file_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder =
        local_var_req_builder.json(&update_an_organization_release_file_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateAnOrganizationReleaseFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Upload a new organization release file.
pub async fn upload_a_new_organization_release_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    version: &str,
    file: std::path::PathBuf,
    name: Option<&str>,
    dist: Option<&str>,
    header: Option<&str>,
) -> Result<(), Error<UploadANewOrganizationReleaseFileError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/organizations/{organization_slug}/releases/{version}/files/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    if let Some(local_var_param_value) = name {
        local_var_form = local_var_form.text("name", local_var_param_value.to_string());
    }
    // TODO: support file upload for 'file' parameter
    if let Some(local_var_param_value) = dist {
        local_var_form = local_var_form.text("dist", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = header {
        local_var_form = local_var_form.text("header", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UploadANewOrganizationReleaseFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Upload a new project release file.
pub async fn upload_a_new_project_release_file(
    configuration: &configuration::Configuration,
    organization_slug: &str,
    project_slug: &str,
    version: &str,
    file: std::path::PathBuf,
    name: Option<&str>,
    dist: Option<&str>,
    header: Option<&str>,
) -> Result<
    crate::models::ListAnOrganizationSReleaseFiles200ResponseInner,
    Error<UploadANewProjectReleaseFileError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/files/",
        local_var_configuration.base_path,
        organization_slug = crate::apis::urlencode(organization_slug),
        project_slug = crate::apis::urlencode(project_slug),
        version = crate::apis::urlencode(version)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    if let Some(local_var_param_value) = name {
        local_var_form = local_var_form.text("name", local_var_param_value.to_string());
    }
    // TODO: support file upload for 'file' parameter
    if let Some(local_var_param_value) = dist {
        local_var_form = local_var_form.text("dist", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = header {
        local_var_form = local_var_form.text("header", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UploadANewProjectReleaseFileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
